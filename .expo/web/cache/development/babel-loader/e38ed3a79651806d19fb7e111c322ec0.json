{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport Animated from \"react-native-reanimated\";\nimport { clamp as clamp1 } from \"./Math\";\nvar Value = Animated.Value,\n  block = Animated.block;\nvar create = function create(x, y) {\n  var _ref;\n  return {\n    x: x != null ? x : 0,\n    y: (_ref = y != null ? y : x) != null ? _ref : 0\n  };\n};\nvar createValue = function createValue() {\n  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var y = arguments.length > 1 ? arguments[1] : undefined;\n  return create(new Value(x), new Value(y != null ? y : x));\n};\nvar isAdaptable = function isAdaptable(value) {\n  return typeof value === \"number\" || value instanceof Animated.Node || value instanceof Animated.Value;\n};\nvar get = function get(vectors, dimension) {\n  return vectors.map(function (vector) {\n    return isAdaptable(vector) ? vector : vector[dimension];\n  });\n};\nvar apply = function apply(fn) {\n  for (var _len = arguments.length, vectors = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    vectors[_key - 1] = arguments[_key];\n  }\n  return {\n    x: fn.apply(void 0, _toConsumableArray(get(vectors, \"x\"))),\n    y: fn.apply(void 0, _toConsumableArray(get(vectors, \"y\")))\n  };\n};\nvar add = function add() {\n  for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    vectors[_key2] = arguments[_key2];\n  }\n  return apply.apply(void 0, [Animated.add].concat(vectors));\n};\nvar sub = function sub() {\n  for (var _len3 = arguments.length, vectors = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    vectors[_key3] = arguments[_key3];\n  }\n  return apply.apply(void 0, [Animated.sub].concat(vectors));\n};\nvar div = function div() {\n  for (var _len4 = arguments.length, vectors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    vectors[_key4] = arguments[_key4];\n  }\n  return apply.apply(void 0, [Animated.divide].concat(vectors));\n};\nvar mul = function mul() {\n  for (var _len5 = arguments.length, vectors = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    vectors[_key5] = arguments[_key5];\n  }\n  return apply.apply(void 0, [Animated.multiply].concat(vectors));\n};\nvar pow = function pow() {\n  for (var _len6 = arguments.length, vectors = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    vectors[_key6] = arguments[_key6];\n  }\n  return apply.apply(void 0, [Animated.pow].concat(vectors));\n};\nvar sqrt = function sqrt() {\n  for (var _len7 = arguments.length, vectors = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    vectors[_key7] = arguments[_key7];\n  }\n  return apply.apply(void 0, [Animated.sqrt].concat(vectors));\n};\nvar cos = function cos() {\n  for (var _len8 = arguments.length, vectors = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n    vectors[_key8] = arguments[_key8];\n  }\n  return apply.apply(void 0, [Animated.cos].concat(vectors));\n};\nvar sin = function sin() {\n  for (var _len9 = arguments.length, vectors = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    vectors[_key9] = arguments[_key9];\n  }\n  return apply.apply(void 0, [Animated.sin].concat(vectors));\n};\nvar min = function min(vector, value) {\n  return apply(Animated.min, vector, value);\n};\nvar max = function max(vector, value) {\n  return apply(Animated.max, vector, value);\n};\nvar clamp = function clamp(value, minVec, maxVec) {\n  return apply(clamp1, value, minVec, maxVec);\n};\nvar minus = function minus(a) {\n  return mul(-1, a);\n};\nvar set = function set(a, b) {\n  return block([Animated.set(a.x, isAdaptable(b) ? b : b.x), Animated.set(a.y, isAdaptable(b) ? b : b.y)]);\n};\nvar length = function length(v) {\n  return Animated.sqrt(Animated.add(Animated.pow(v.x, 2), Animated.pow(v.y, 2)));\n};\nvar normalize = function normalize(v) {\n  return div(v, length(v));\n};\nvar dot = function dot(v1, v2) {\n  return add(Animated.multiply(v1.x, v2.x), Animated.multiply(v1.y, v2.y));\n};\nvar cross = function cross(v1, v2) {\n  return sub(Animated.multiply(v1.x, v2.y), Animated.multiply(v1.y, v2.x));\n};\nexport var vec = {\n  create: create,\n  createValue: createValue,\n  minus: minus,\n  add: add,\n  sub: sub,\n  dot: dot,\n  div: div,\n  mul: mul,\n  multiply: mul,\n  divide: div,\n  pow: pow,\n  sqrt: sqrt,\n  set: set,\n  clamp: clamp,\n  apply: apply,\n  min: min,\n  max: max,\n  cos: cos,\n  sin: sin,\n  length: length,\n  normalize: normalize,\n  cross: cross\n};","map":{"version":3,"mappings":"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","names":["Animated","clamp","clamp1","Value","block","create","x","y","createValue","isAdaptable","value","Node","get","vectors","dimension","map","vector","apply","fn","add","sub","div","divide","mul","multiply","pow","sqrt","cos","sin","min","max","minVec","maxVec","minus","a","set","b","length","v","normalize","dot","v1","v2","cross","vec"],"sources":["Vectors.ts"],"sourcesContent":["import Animated from \"react-native-reanimated\";\n\nimport { clamp as clamp1 } from \"./Math\";\n\nconst { Value, block } = Animated;\ntype Dimension = \"x\" | \"y\";\ntype Fn = (...args: Animated.Adaptable<number>[]) => Animated.Node<number>;\ntype Adaptable = Vector | Animated.Adaptable<number>;\ntype SingleArgOp<T extends Adaptable = Adaptable> = [T];\ntype BinArgOp<T extends Adaptable = Adaptable> = [T, T, ...T[]];\n\nexport interface Vector<\n  T extends Animated.Adaptable<number> = Animated.Adaptable<number>\n> {\n  x: T;\n  y: T;\n}\n\ntype Create = {\n  (): Vector<0>;\n  <T extends Animated.Adaptable<number>>(x: T, y?: T): Vector<T>;\n};\n\nconst create: Create = <T extends Animated.Adaptable<number>>(\n  x?: T,\n  y?: T\n) => ({\n  x: x ?? 0,\n  y: y ?? x ?? 0,\n});\n\nconst createValue = (x = 0, y?: number) =>\n  create(new Value(x), new Value(y ?? x));\n\nconst isAdaptable = (value: Adaptable): value is Animated.Adaptable<number> =>\n  typeof value === \"number\" ||\n  value instanceof Animated.Node ||\n  value instanceof Animated.Value;\n\nconst get = (vectors: Adaptable[], dimension: Dimension) =>\n  vectors.map((vector) => (isAdaptable(vector) ? vector : vector[dimension]));\n\nconst apply = (fn: Fn, ...vectors: Adaptable[]) => ({\n  x: fn(...get(vectors, \"x\")),\n  y: fn(...get(vectors, \"y\")),\n});\n\nconst add = (...vectors: BinArgOp) => apply(Animated.add, ...vectors);\nconst sub = (...vectors: BinArgOp) => apply(Animated.sub, ...vectors);\nconst div = (...vectors: BinArgOp) => apply(Animated.divide, ...vectors);\nconst mul = (...vectors: BinArgOp) => apply(Animated.multiply, ...vectors);\nconst pow = (...vectors: [Adaptable, number]) =>\n  apply(Animated.pow, ...vectors);\nconst sqrt = (...vectors: SingleArgOp) => apply(Animated.sqrt, ...vectors);\nconst cos = (...vectors: SingleArgOp) => apply(Animated.cos, ...vectors);\nconst sin = (...vectors: SingleArgOp) => apply(Animated.sin, ...vectors);\nconst min = (vector: Adaptable, value: Animated.Adaptable<number>) =>\n  apply(Animated.min, vector, value);\nconst max = (vector: Adaptable, value: Animated.Adaptable<number>) =>\n  apply(Animated.max, vector, value);\nconst clamp = (value: Adaptable, minVec: Adaptable, maxVec: Adaptable) =>\n  apply(clamp1, value, minVec, maxVec);\n\nconst minus = (a: Adaptable) => mul(-1, a);\n\nconst set = (a: Vector<Animated.Value<number>>, b: Adaptable) =>\n  block([\n    Animated.set(a.x, isAdaptable(b) ? b : b.x),\n    Animated.set(a.y, isAdaptable(b) ? b : b.y),\n  ]);\n\nconst length = (v: Vector) =>\n  Animated.sqrt(Animated.add(Animated.pow(v.x, 2), Animated.pow(v.y, 2)));\nconst normalize = (v: Vector) => div(v, length(v));\nconst dot = (v1: Vector, v2: Vector) =>\n  add(Animated.multiply(v1.x, v2.x), Animated.multiply(v1.y, v2.y));\nconst cross = (v1: Vector, v2: Vector) =>\n  sub(Animated.multiply(v1.x, v2.y), Animated.multiply(v1.y, v2.x));\n\nexport const vec = {\n  create,\n  createValue,\n  minus,\n  add,\n  sub,\n  dot,\n  div,\n  mul,\n  multiply: mul,\n  divide: div,\n  pow,\n  sqrt,\n  set,\n  clamp,\n  apply,\n  min,\n  max,\n  cos,\n  sin,\n  length,\n  normalize,\n  cross,\n};\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"uri\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\nimport { RECORDING_OPTIONS_PRESET_HIGH_QUALITY } from \"./Audio/RecordingConstants\";\nfunction getPermissionWithQueryAsync(name) {\n  var _await$navigator$perm, state;\n  return _regeneratorRuntime.async(function getPermissionWithQueryAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          if (!(!navigator || !navigator.permissions || !navigator.permissions.query)) {\n            _context.next = 2;\n            break;\n          }\n          return _context.abrupt(\"return\", null);\n        case 2:\n          _context.prev = 2;\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(navigator.permissions.query({\n            name: name\n          }));\n        case 5:\n          _await$navigator$perm = _context.sent;\n          state = _await$navigator$perm.state;\n          _context.t0 = state;\n          _context.next = _context.t0 === 'granted' ? 10 : _context.t0 === 'denied' ? 11 : 12;\n          break;\n        case 10:\n          return _context.abrupt(\"return\", PermissionStatus.GRANTED);\n        case 11:\n          return _context.abrupt(\"return\", PermissionStatus.DENIED);\n        case 12:\n          return _context.abrupt(\"return\", PermissionStatus.UNDETERMINED);\n        case 13:\n          _context.next = 18;\n          break;\n        case 15:\n          _context.prev = 15;\n          _context.t1 = _context[\"catch\"](2);\n          return _context.abrupt(\"return\", PermissionStatus.UNDETERMINED);\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[2, 15]], Promise);\n}\nfunction getUserMedia(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n  var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || function () {\n    var error = new Error('Permission unimplemented');\n    error.code = 0;\n    error.name = 'NotAllowedError';\n    throw error;\n  };\n  return new Promise(function (resolve, reject) {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\nfunction getStatusFromMedia(media) {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined\n    };\n  }\n  var isPlaying = !!(media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2);\n  var status = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100,\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    shouldPlay: media.autoplay,\n    isPlaying: isPlaying,\n    isBuffering: false,\n    rate: media.playbackRate,\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended\n  };\n  return status;\n}\nfunction setStatusForMedia(media, status) {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n  return getStatusFromMedia(media);\n}\nvar mediaRecorder = null;\nvar mediaRecorderUptimeOfLastStartResume = 0;\nvar mediaRecorderDurationAlreadyRecorded = 0;\nvar mediaRecorderIsRecording = false;\nfunction getAudioRecorderDurationMillis() {\n  var duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\nexport default {\n  get name() {\n    return 'ExponentAV';\n  },\n  getStatusForVideo: function getStatusForVideo(element) {\n    return function _callee() {\n      return _regeneratorRuntime.async(function _callee$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", getStatusFromMedia(element));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  loadForVideo: function loadForVideo(element, nativeSource, fullInitialStatus) {\n    return function _callee2() {\n      return _regeneratorRuntime.async(function _callee2$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", getStatusFromMedia(element));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  unloadForVideo: function unloadForVideo(element) {\n    return function _callee3() {\n      return _regeneratorRuntime.async(function _callee3$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              return _context4.abrupt(\"return\", getStatusFromMedia(element));\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setStatusForVideo: function setStatusForVideo(element, status) {\n    return function _callee4() {\n      return _regeneratorRuntime.async(function _callee4$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              return _context5.abrupt(\"return\", setStatusForMedia(element, status));\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  replayVideo: function replayVideo(element, status) {\n    return function _callee5() {\n      return _regeneratorRuntime.async(function _callee5$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              return _context6.abrupt(\"return\", setStatusForMedia(element, status));\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setAudioMode: function setAudioMode() {\n    return function _callee6() {\n      return _regeneratorRuntime.async(function _callee6$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setAudioIsEnabled: function setAudioIsEnabled() {\n    return function _callee7() {\n      return _regeneratorRuntime.async(function _callee7$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  getStatusForSound: function getStatusForSound(element) {\n    return function _callee8() {\n      return _regeneratorRuntime.async(function _callee8$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", getStatusFromMedia(element));\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  loadForSound: function loadForSound(nativeSource, fullInitialStatus) {\n    return function _callee9() {\n      var source, media, status;\n      return _regeneratorRuntime.async(function _callee9$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n              media = new Audio(source);\n              media.ontimeupdate = function () {\n                SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n                  key: media,\n                  status: getStatusFromMedia(media)\n                });\n              };\n              media.onerror = function () {\n                SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n                  key: media,\n                  error: media.error.message\n                });\n              };\n              status = setStatusForMedia(media, fullInitialStatus);\n              return _context10.abrupt(\"return\", [media, status]);\n            case 6:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  unloadForSound: function unloadForSound(element) {\n    return function _callee10() {\n      return _regeneratorRuntime.async(function _callee10$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              element.pause();\n              element.removeAttribute('src');\n              element.load();\n              return _context11.abrupt(\"return\", getStatusFromMedia(element));\n            case 4:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  setStatusForSound: function setStatusForSound(element, status) {\n    return function _callee11() {\n      return _regeneratorRuntime.async(function _callee11$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              return _context12.abrupt(\"return\", setStatusForMedia(element, status));\n            case 1:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  replaySound: function replaySound(element, status) {\n    return function _callee12() {\n      return _regeneratorRuntime.async(function _callee12$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              return _context13.abrupt(\"return\", setStatusForMedia(element, status));\n            case 1:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  getAudioRecordingStatus: function getAudioRecordingStatus() {\n    return function _callee13() {\n      var _mediaRecorder, _mediaRecorder2, _mediaRecorder3;\n      return _regeneratorRuntime.async(function _callee13$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              return _context14.abrupt(\"return\", {\n                canRecord: ((_mediaRecorder = mediaRecorder) == null ? void 0 : _mediaRecorder.state) === 'recording' || ((_mediaRecorder2 = mediaRecorder) == null ? void 0 : _mediaRecorder2.state) === 'inactive',\n                isRecording: ((_mediaRecorder3 = mediaRecorder) == null ? void 0 : _mediaRecorder3.state) === 'recording',\n                isDoneRecording: false,\n                durationMillis: getAudioRecorderDurationMillis(),\n                uri: null\n              });\n            case 1:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  prepareAudioRecorder: function prepareAudioRecorder(options) {\n    var _this = this;\n    return function _callee14() {\n      var stream, _await$_this$getAudio, uri, status;\n      return _regeneratorRuntime.async(function _callee14$(_context15) {\n        while (1) {\n          switch (_context15.prev = _context15.next) {\n            case 0:\n              if (!(typeof navigator !== 'undefined' && !navigator.mediaDevices)) {\n                _context15.next = 2;\n                break;\n              }\n              throw new Error('No media devices available');\n            case 2:\n              mediaRecorderUptimeOfLastStartResume = 0;\n              mediaRecorderDurationAlreadyRecorded = 0;\n              _context15.next = 6;\n              return _regeneratorRuntime.awrap(getUserMedia({\n                audio: true\n              }));\n            case 6:\n              stream = _context15.sent;\n              mediaRecorder = new window.MediaRecorder(stream, (options == null ? void 0 : options.web) || RECORDING_OPTIONS_PRESET_HIGH_QUALITY.web);\n              mediaRecorder.addEventListener('pause', function () {\n                mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n                mediaRecorderIsRecording = false;\n              });\n              mediaRecorder.addEventListener('resume', function () {\n                mediaRecorderUptimeOfLastStartResume = Date.now();\n                mediaRecorderIsRecording = true;\n              });\n              mediaRecorder.addEventListener('start', function () {\n                mediaRecorderUptimeOfLastStartResume = Date.now();\n                mediaRecorderDurationAlreadyRecorded = 0;\n                mediaRecorderIsRecording = true;\n              });\n              mediaRecorder.addEventListener('stop', function () {\n                mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n                mediaRecorderIsRecording = false;\n                stream.getTracks().forEach(function (track) {\n                  return track.stop();\n                });\n              });\n              _context15.next = 14;\n              return _regeneratorRuntime.awrap(_this.getAudioRecordingStatus());\n            case 14:\n              _await$_this$getAudio = _context15.sent;\n              uri = _await$_this$getAudio.uri;\n              status = _objectWithoutProperties(_await$_this$getAudio, _excluded);\n              return _context15.abrupt(\"return\", {\n                uri: null,\n                status: status\n              });\n            case 18:\n            case \"end\":\n              return _context15.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  startAudioRecording: function startAudioRecording() {\n    var _this2 = this;\n    return function _callee15() {\n      return _regeneratorRuntime.async(function _callee15$(_context16) {\n        while (1) {\n          switch (_context16.prev = _context16.next) {\n            case 0:\n              if (!(mediaRecorder === null)) {\n                _context16.next = 2;\n                break;\n              }\n              throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n            case 2:\n              if (mediaRecorder.state === 'paused') {\n                mediaRecorder.resume();\n              } else {\n                mediaRecorder.start();\n              }\n              return _context16.abrupt(\"return\", _this2.getAudioRecordingStatus());\n            case 4:\n            case \"end\":\n              return _context16.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  pauseAudioRecording: function pauseAudioRecording() {\n    var _this3 = this;\n    return function _callee16() {\n      return _regeneratorRuntime.async(function _callee16$(_context17) {\n        while (1) {\n          switch (_context17.prev = _context17.next) {\n            case 0:\n              if (!(mediaRecorder === null)) {\n                _context17.next = 2;\n                break;\n              }\n              throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n            case 2:\n              mediaRecorder.pause();\n              return _context17.abrupt(\"return\", _this3.getAudioRecordingStatus());\n            case 4:\n            case \"end\":\n              return _context17.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  stopAudioRecording: function stopAudioRecording() {\n    var _this4 = this;\n    return function _callee17() {\n      var dataPromise, data, url;\n      return _regeneratorRuntime.async(function _callee17$(_context18) {\n        while (1) {\n          switch (_context18.prev = _context18.next) {\n            case 0:\n              if (!(mediaRecorder === null)) {\n                _context18.next = 2;\n                break;\n              }\n              throw new Error('Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.');\n            case 2:\n              if (!(mediaRecorder.state === 'inactive')) {\n                _context18.next = 4;\n                break;\n              }\n              return _context18.abrupt(\"return\", _this4.getAudioRecordingStatus());\n            case 4:\n              dataPromise = new Promise(function (resolve) {\n                return mediaRecorder.addEventListener('dataavailable', function (e) {\n                  return resolve(e.data);\n                });\n              });\n              mediaRecorder.stop();\n              _context18.next = 8;\n              return _regeneratorRuntime.awrap(dataPromise);\n            case 8:\n              data = _context18.sent;\n              url = URL.createObjectURL(data);\n              _context18.t0 = _objectSpread;\n              _context18.t1 = _objectSpread;\n              _context18.t2 = {};\n              _context18.next = 15;\n              return _regeneratorRuntime.awrap(_this4.getAudioRecordingStatus());\n            case 15:\n              _context18.t3 = _context18.sent;\n              _context18.t4 = (0, _context18.t1)(_context18.t2, _context18.t3);\n              _context18.t5 = {};\n              _context18.t6 = {\n                uri: url\n              };\n              return _context18.abrupt(\"return\", (0, _context18.t0)(_context18.t4, _context18.t5, _context18.t6));\n            case 20:\n            case \"end\":\n              return _context18.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  unloadAudioRecorder: function unloadAudioRecorder() {\n    return function _callee18() {\n      return _regeneratorRuntime.async(function _callee18$(_context19) {\n        while (1) {\n          switch (_context19.prev = _context19.next) {\n            case 0:\n              mediaRecorder = null;\n            case 1:\n            case \"end\":\n              return _context19.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  getPermissionsAsync: function getPermissionsAsync() {\n    var _this5 = this;\n    return function _callee19() {\n      var maybeStatus;\n      return _regeneratorRuntime.async(function _callee19$(_context20) {\n        while (1) {\n          switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return _regeneratorRuntime.awrap(getPermissionWithQueryAsync('microphone'));\n            case 2:\n              maybeStatus = _context20.sent;\n              _context20.t0 = maybeStatus;\n              _context20.next = _context20.t0 === PermissionStatus.GRANTED ? 6 : _context20.t0 === PermissionStatus.DENIED ? 7 : 8;\n              break;\n            case 6:\n              return _context20.abrupt(\"return\", {\n                status: PermissionStatus.GRANTED,\n                expires: 'never',\n                canAskAgain: true,\n                granted: true\n              });\n            case 7:\n              return _context20.abrupt(\"return\", {\n                status: PermissionStatus.DENIED,\n                expires: 'never',\n                canAskAgain: true,\n                granted: false\n              });\n            case 8:\n              _context20.next = 10;\n              return _regeneratorRuntime.awrap(_this5.requestPermissionsAsync());\n            case 10:\n              return _context20.abrupt(\"return\", _context20.sent);\n            case 11:\n            case \"end\":\n              return _context20.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }();\n  },\n  requestPermissionsAsync: function requestPermissionsAsync() {\n    return function _callee20() {\n      var stream;\n      return _regeneratorRuntime.async(function _callee20$(_context21) {\n        while (1) {\n          switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.prev = 0;\n              _context21.next = 3;\n              return _regeneratorRuntime.awrap(getUserMedia({\n                audio: true\n              }));\n            case 3:\n              stream = _context21.sent;\n              stream.getTracks().forEach(function (track) {\n                return track.stop();\n              });\n              return _context21.abrupt(\"return\", {\n                status: PermissionStatus.GRANTED,\n                expires: 'never',\n                canAskAgain: true,\n                granted: true\n              });\n            case 8:\n              _context21.prev = 8;\n              _context21.t0 = _context21[\"catch\"](0);\n              return _context21.abrupt(\"return\", {\n                status: PermissionStatus.DENIED,\n                expires: 'never',\n                canAskAgain: true,\n                granted: false\n              });\n            case 11:\n            case \"end\":\n              return _context21.stop();\n          }\n        }\n      }, null, null, [[0, 8]], Promise);\n    }();\n  }\n};","map":{"version":3,"mappings":"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","names":["PermissionStatus","SyntheticPlatformEmitter","RECORDING_OPTIONS_PRESET_HIGH_QUALITY","getPermissionWithQueryAsync","name","navigator","permissions","query","state","GRANTED","DENIED","UNDETERMINED","getUserMedia","constraints","mediaDevices","webkitGetUserMedia","mozGetUserMedia","error","Error","code","Promise","resolve","reject","call","getStatusFromMedia","media","isLoaded","undefined","isPlaying","currentTime","paused","ended","readyState","status","uri","src","progressUpdateIntervalMillis","durationMillis","duration","positionMillis","shouldPlay","autoplay","isBuffering","rate","playbackRate","shouldCorrectPitch","volume","isMuted","muted","isLooping","loop","didJustFinish","setStatusForMedia","play","pause","mediaRecorder","mediaRecorderUptimeOfLastStartResume","mediaRecorderDurationAlreadyRecorded","mediaRecorderIsRecording","getAudioRecorderDurationMillis","Date","now","getStatusForVideo","element","loadForVideo","nativeSource","fullInitialStatus","unloadForVideo","setStatusForVideo","replayVideo","setAudioMode","setAudioIsEnabled","getStatusForSound","loadForSound","source","Audio","ontimeupdate","emit","key","onerror","message","unloadForSound","removeAttribute","load","setStatusForSound","replaySound","getAudioRecordingStatus","canRecord","isRecording","isDoneRecording","prepareAudioRecorder","options","audio","stream","window","MediaRecorder","web","addEventListener","getTracks","forEach","track","stop","startAudioRecording","resume","start","pauseAudioRecording","stopAudioRecording","dataPromise","e","data","url","URL","createObjectURL","unloadAudioRecorder","getPermissionsAsync","maybeStatus","expires","canAskAgain","granted","requestPermissionsAsync"],"sourceRoot":"","sources":["../src/ExponentAV.web.ts"],"sourcesContent":["import { PermissionResponse, PermissionStatus, SyntheticPlatformEmitter } from 'expo-modules-core';\n\nimport type { AVPlaybackNativeSource, AVPlaybackStatus, AVPlaybackStatusToSet } from './AV.types';\nimport type { RecordingStatus } from './Audio/Recording.types';\nimport { RECORDING_OPTIONS_PRESET_HIGH_QUALITY } from './Audio/RecordingConstants';\n\nasync function getPermissionWithQueryAsync(\n  name: PermissionNameWithAdditionalValues\n): Promise<PermissionStatus | null> {\n  if (!navigator || !navigator.permissions || !navigator.permissions.query) return null;\n\n  try {\n    const { state } = await navigator.permissions.query({ name });\n    switch (state) {\n      case 'granted':\n        return PermissionStatus.GRANTED;\n      case 'denied':\n        return PermissionStatus.DENIED;\n      default:\n        return PermissionStatus.UNDETERMINED;\n    }\n  } catch (error) {\n    // FireFox - TypeError: 'microphone' (value of 'name' member of PermissionDescriptor) is not a valid value for enumeration PermissionName.\n    return PermissionStatus.UNDETERMINED;\n  }\n}\n\nfunction getUserMedia(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  // Some browsers partially implement mediaDevices. We can't just assign an object\n  // with getUserMedia as it would overwrite existing properties.\n  // Here, we will just add the getUserMedia property if it's missing.\n\n  // First get ahold of the legacy getUserMedia, if present\n  const getUserMedia =\n    // TODO: this method is deprecated, migrate to https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    navigator.getUserMedia ||\n    navigator.webkitGetUserMedia ||\n    navigator.mozGetUserMedia ||\n    function () {\n      const error: any = new Error('Permission unimplemented');\n      error.code = 0;\n      error.name = 'NotAllowedError';\n      throw error;\n    };\n\n  return new Promise((resolve, reject) => {\n    getUserMedia.call(navigator, constraints, resolve, reject);\n  });\n}\n\nfunction getStatusFromMedia(media?: HTMLMediaElement): AVPlaybackStatus {\n  if (!media) {\n    return {\n      isLoaded: false,\n      error: undefined,\n    };\n  }\n\n  const isPlaying = !!(\n    media.currentTime > 0 &&\n    !media.paused &&\n    !media.ended &&\n    media.readyState > 2\n  );\n\n  const status: AVPlaybackStatus = {\n    isLoaded: true,\n    uri: media.src,\n    progressUpdateIntervalMillis: 100, //TODO: Bacon: Add interval between calls\n    durationMillis: media.duration * 1000,\n    positionMillis: media.currentTime * 1000,\n    // playableDurationMillis: media.buffered * 1000,\n    // seekMillisToleranceBefore?: number\n    // seekMillisToleranceAfter?: number\n    shouldPlay: media.autoplay,\n    isPlaying,\n    isBuffering: false, //media.waiting,\n    rate: media.playbackRate,\n    // TODO: Bacon: This seems too complicated right now: https://webaudio.github.io/web-audio-api/#dom-biquadfilternode-frequency\n    shouldCorrectPitch: false,\n    volume: media.volume,\n    isMuted: media.muted,\n    isLooping: media.loop,\n    didJustFinish: media.ended,\n  };\n\n  return status;\n}\n\nfunction setStatusForMedia(\n  media: HTMLMediaElement,\n  status: AVPlaybackStatusToSet\n): AVPlaybackStatus {\n  if (status.positionMillis !== undefined) {\n    media.currentTime = status.positionMillis / 1000;\n  }\n  // if (status.progressUpdateIntervalMillis !== undefined) {\n  //   media.progressUpdateIntervalMillis = status.progressUpdateIntervalMillis;\n  // }\n  // if (status.seekMillisToleranceBefore !== undefined) {\n  //   media.seekMillisToleranceBefore = status.seekMillisToleranceBefore;\n  // }\n  // if (status.seekMillisToleranceAfter !== undefined) {\n  //   media.seekMillisToleranceAfter = status.seekMillisToleranceAfter;\n  // }\n  // if (status.shouldCorrectPitch !== undefined) {\n  //   media.shouldCorrectPitch = status.shouldCorrectPitch;\n  // }\n  if (status.shouldPlay !== undefined) {\n    if (status.shouldPlay) {\n      media.play();\n    } else {\n      media.pause();\n    }\n  }\n  if (status.rate !== undefined) {\n    media.playbackRate = status.rate;\n  }\n  if (status.volume !== undefined) {\n    media.volume = status.volume;\n  }\n  if (status.isMuted !== undefined) {\n    media.muted = status.isMuted;\n  }\n  if (status.isLooping !== undefined) {\n    media.loop = status.isLooping;\n  }\n\n  return getStatusFromMedia(media);\n}\n\nlet mediaRecorder: null | any /*MediaRecorder*/ = null;\nlet mediaRecorderUptimeOfLastStartResume: number = 0;\nlet mediaRecorderDurationAlreadyRecorded: number = 0;\nlet mediaRecorderIsRecording: boolean = false;\n\nfunction getAudioRecorderDurationMillis() {\n  let duration = mediaRecorderDurationAlreadyRecorded;\n  if (mediaRecorderIsRecording && mediaRecorderUptimeOfLastStartResume > 0) {\n    duration += Date.now() - mediaRecorderUptimeOfLastStartResume;\n  }\n  return duration;\n}\n\nexport default {\n  get name(): string {\n    return 'ExponentAV';\n  },\n  async getStatusForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async loadForVideo(\n    element: HTMLMediaElement,\n    nativeSource: AVPlaybackNativeSource,\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async unloadForVideo(element: HTMLMediaElement): Promise<AVPlaybackStatus> {\n    return getStatusFromMedia(element);\n  },\n  async setStatusForVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replayVideo(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  /* Audio */\n  async setAudioMode() {},\n  async setAudioIsEnabled() {},\n  async getStatusForSound(element: HTMLMediaElement) {\n    return getStatusFromMedia(element);\n  },\n  async loadForSound(\n    nativeSource: string | { uri: string; [key: string]: any },\n    fullInitialStatus: AVPlaybackStatusToSet\n  ): Promise<[HTMLMediaElement, AVPlaybackStatus]> {\n    const source = typeof nativeSource === 'string' ? nativeSource : nativeSource.uri;\n    const media = new Audio(source);\n\n    media.ontimeupdate = () => {\n      SyntheticPlatformEmitter.emit('didUpdatePlaybackStatus', {\n        key: media,\n        status: getStatusFromMedia(media),\n      });\n    };\n\n    media.onerror = () => {\n      SyntheticPlatformEmitter.emit('ExponentAV.onError', {\n        key: media,\n        error: media.error!.message,\n      });\n    };\n\n    const status = setStatusForMedia(media, fullInitialStatus);\n\n    return [media, status];\n  },\n  async unloadForSound(element: HTMLMediaElement) {\n    element.pause();\n    element.removeAttribute('src');\n    element.load();\n    return getStatusFromMedia(element);\n  },\n  async setStatusForSound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n  async replaySound(\n    element: HTMLMediaElement,\n    status: AVPlaybackStatusToSet\n  ): Promise<AVPlaybackStatus> {\n    return setStatusForMedia(element, status);\n  },\n\n  /* Recording */\n  //   async setUnloadedCallbackForAndroidRecording() {},\n  async getAudioRecordingStatus(): Promise<RecordingStatus> {\n    return {\n      canRecord: mediaRecorder?.state === 'recording' || mediaRecorder?.state === 'inactive',\n      isRecording: mediaRecorder?.state === 'recording',\n      isDoneRecording: false,\n      durationMillis: getAudioRecorderDurationMillis(),\n      uri: null,\n    };\n  },\n  async prepareAudioRecorder(options): Promise<{\n    uri: string | null;\n    // status is of type RecordingStatus, but without the canRecord field populated\n    status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n  }> {\n    if (typeof navigator !== 'undefined' && !navigator.mediaDevices) {\n      throw new Error('No media devices available');\n    }\n\n    mediaRecorderUptimeOfLastStartResume = 0;\n    mediaRecorderDurationAlreadyRecorded = 0;\n\n    const stream = await getUserMedia({ audio: true });\n\n    mediaRecorder = new (window as any).MediaRecorder(\n      stream,\n      options?.web || RECORDING_OPTIONS_PRESET_HIGH_QUALITY.web\n    );\n\n    mediaRecorder.addEventListener('pause', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n    });\n\n    mediaRecorder.addEventListener('resume', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('start', () => {\n      mediaRecorderUptimeOfLastStartResume = Date.now();\n      mediaRecorderDurationAlreadyRecorded = 0;\n      mediaRecorderIsRecording = true;\n    });\n\n    mediaRecorder.addEventListener('stop', () => {\n      mediaRecorderDurationAlreadyRecorded = getAudioRecorderDurationMillis();\n      mediaRecorderIsRecording = false;\n\n      // Clears recording icon in Chrome tab\n      stream.getTracks().forEach((track) => track.stop());\n    });\n\n    const { uri, ...status } = await this.getAudioRecordingStatus();\n\n    return { uri: null, status };\n  },\n  async startAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'paused') {\n      mediaRecorder.resume();\n    } else {\n      mediaRecorder.start();\n    }\n\n    return this.getAudioRecordingStatus();\n  },\n  async pauseAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    // Set status to paused\n    mediaRecorder.pause();\n\n    return this.getAudioRecordingStatus();\n  },\n  async stopAudioRecording(): Promise<RecordingStatus> {\n    if (mediaRecorder === null) {\n      throw new Error(\n        'Cannot start an audio recording without initializing a MediaRecorder. Run prepareToRecordAsync() before attempting to start an audio recording.'\n      );\n    }\n\n    if (mediaRecorder.state === 'inactive') {\n      return this.getAudioRecordingStatus();\n    }\n\n    const dataPromise = new Promise((resolve) =>\n      mediaRecorder.addEventListener('dataavailable', (e) => resolve(e.data))\n    );\n\n    mediaRecorder.stop();\n\n    const data = await dataPromise;\n    const url = URL.createObjectURL(data);\n\n    return {\n      ...(await this.getAudioRecordingStatus()),\n      uri: url,\n    };\n  },\n  async unloadAudioRecorder(): Promise<void> {\n    mediaRecorder = null;\n  },\n\n  async getPermissionsAsync(): Promise<PermissionResponse> {\n    const maybeStatus = await getPermissionWithQueryAsync('microphone');\n    switch (maybeStatus) {\n      case PermissionStatus.GRANTED:\n        return {\n          status: PermissionStatus.GRANTED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: true,\n        };\n      case PermissionStatus.DENIED:\n        return {\n          status: PermissionStatus.DENIED,\n          expires: 'never',\n          canAskAgain: true,\n          granted: false,\n        };\n      default:\n        return await this.requestPermissionsAsync();\n    }\n  },\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      const stream = await getUserMedia({ audio: true });\n      stream.getTracks().forEach((track) => track.stop());\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: true,\n      };\n    } catch (e) {\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n    }\n  },\n};\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _taggedTemplateLiteralLoose from \"@babel/runtime/helpers/taggedTemplateLiteralLoose\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\nfunction _templateObject2() {\n  var data = _taggedTemplateLiteralLoose([\"M\", \",\", \" \"]);\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n  return data;\n}\nfunction _templateObject() {\n  var data = _taggedTemplateLiteralLoose([\"\", \"C\", \",\", \" \", \",\", \" \", \",\", \"\"]);\n  _templateObject = function _templateObject() {\n    return data;\n  };\n  return data;\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nimport Animated from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\nimport { get } from \"./Array\";\nimport { string } from \"./String\";\nimport { cubicBezier } from \"./Math\";\nimport cubicBezierLength from \"./bezier/CubicBezierLength\";\nimport cubicBezierSolve from \"./bezier/CubicBezierSolve\";\nvar Value = Animated.Value,\n  lessOrEq = Animated.lessOrEq,\n  greaterOrEq = Animated.greaterOrEq,\n  and = Animated.and,\n  cond = Animated.cond,\n  interpolate = Animated.interpolate,\n  multiply = Animated.multiply,\n  lessThan = Animated.lessThan,\n  concat = Animated.concat,\n  add = Animated.add;\nvar MX = 1;\nvar MY = 2;\nvar CX1 = 1;\nvar CY1 = 2;\nvar CX2 = 3;\nvar CY2 = 4;\nvar CX = 5;\nvar CY = 6;\nexport var parsePath = function parsePath(d) {\n  var _normalizeSVG = normalizeSVG(absSVG(parseSVG(d))),\n    _normalizeSVG2 = _toArray(_normalizeSVG),\n    move = _normalizeSVG2[0],\n    curves = _normalizeSVG2.slice(1);\n  var parts = curves.map(function (curve, index) {\n    var prevCurve = curves[index - 1];\n    var p0 = index === 0 ? {\n      x: move[MX],\n      y: move[MY]\n    } : {\n      x: prevCurve[CX],\n      y: prevCurve[CY]\n    };\n    var p1 = {\n      x: curve[CX1],\n      y: curve[CY1]\n    };\n    var p2 = {\n      x: curve[CX2],\n      y: curve[CY2]\n    };\n    var p3 = {\n      x: curve[CX],\n      y: curve[CY]\n    };\n    var length = cubicBezierLength(p0, p1, p2, p3);\n    return {\n      p0: p0,\n      p1: p1,\n      p2: p2,\n      p3: p3,\n      length: length\n    };\n  });\n  var segments = parts.map(function (part, index) {\n    var start = parts.slice(0, index).reduce(function (acc, p) {\n      return acc + p.length;\n    }, 0);\n    var end = start + part.length;\n    return {\n      start: start,\n      end: end,\n      p0x: part.p0.x,\n      p3x: part.p3.x\n    };\n  });\n  return {\n    segments: segments,\n    totalLength: parts.reduce(function (acc, part) {\n      return acc + part.length;\n    }, 0),\n    length: parts.map(function (part) {\n      return part.length;\n    }),\n    start: segments.map(function (segment) {\n      return segment.start;\n    }),\n    end: segments.map(function (segment) {\n      return segment.end;\n    }),\n    p0x: parts.map(function (part) {\n      return part.p0.x;\n    }),\n    p0y: parts.map(function (part) {\n      return part.p0.y;\n    }),\n    p1x: parts.map(function (part) {\n      return part.p1.x;\n    }),\n    p1y: parts.map(function (part) {\n      return part.p1.y;\n    }),\n    p2x: parts.map(function (part) {\n      return part.p2.x;\n    }),\n    p2y: parts.map(function (part) {\n      return part.p2.y;\n    }),\n    p3x: parts.map(function (part) {\n      return part.p3.x;\n    }),\n    p3y: parts.map(function (part) {\n      return part.p3.y;\n    })\n  };\n};\nexport var getPointAtLength = function getPointAtLength(path, length) {\n  var notFound = new Value(-1);\n  var index = path.segments.reduce(function (acc, p, i) {\n    return cond(and(greaterOrEq(length, p.start), lessOrEq(length, p.end)), i, acc);\n  }, notFound);\n  var start = get(path.start, index);\n  var end = get(path.end, index);\n  var p0x = get(path.p0x, index);\n  var p1x = get(path.p1x, index);\n  var p2x = get(path.p2x, index);\n  var p3x = get(path.p3x, index);\n  var p0y = get(path.p0y, index);\n  var p1y = get(path.p1y, index);\n  var p2y = get(path.p2y, index);\n  var p3y = get(path.p3y, index);\n  var t = interpolate(length, {\n    inputRange: [start, end],\n    outputRange: [0, 1]\n  });\n  return {\n    x: cubicBezier(t, p0x, p1x, p2x, p3x),\n    y: cubicBezier(t, p0y, p1y, p2y, p3y)\n  };\n};\nexport var interpolatePath = function interpolatePath(value, _ref) {\n  var inputRange = _ref.inputRange,\n    outputRange = _ref.outputRange,\n    config = _objectWithoutProperties(_ref, [\"inputRange\", \"outputRange\"]);\n  var paths = outputRange.map(function (path) {\n    return typeof path === \"string\" ? parsePath(path) : path;\n  });\n  var _paths = _slicedToArray(paths, 1),\n    path = _paths[0];\n  var commands = path.segments.map(function (_, index) {\n    var interpolatePoint = function interpolatePoint(point) {\n      return interpolate(value, _objectSpread({\n        inputRange: inputRange,\n        outputRange: paths.map(function (p) {\n          return p[point][index];\n        })\n      }, config));\n    };\n    var mx = interpolatePoint(\"p0x\");\n    var my = interpolatePoint(\"p0y\");\n    var p1x = interpolatePoint(\"p1x\");\n    var p1y = interpolatePoint(\"p1y\");\n    var p2x = interpolatePoint(\"p2x\");\n    var p2y = interpolatePoint(\"p2y\");\n    var p3x = interpolatePoint(\"p3x\");\n    var p3y = interpolatePoint(\"p3y\");\n    return string(_templateObject(), index === 0 ? string(_templateObject2(), mx, my) : \"\", p1x, p1y, p2x, p2y, p3x, p3y);\n  });\n  return concat.apply(void 0, _toConsumableArray(commands));\n};\nexport var bInterpolatePath = function bInterpolatePath(value, path1, path2) {\n  return interpolatePath(value, {\n    inputRange: [0, 1],\n    outputRange: [path1, path2]\n  });\n};\nexport var getLengthAtX = function getLengthAtX(path, x) {\n  var notFound = new Value(-1);\n  var index = path.segments.reduce(function (acc, p, i) {\n    return cond(and(greaterOrEq(x, p.p0x), lessOrEq(x, p.p3x)), i, acc);\n  }, notFound);\n  var p0 = get(path.p0x, index);\n  var p1 = get(path.p1x, index);\n  var p2 = get(path.p2x, index);\n  var p3 = get(path.p3x, index);\n  var t = cubicBezierSolve(p0, p1, p2, p3);\n  var length = get(path.length, index);\n  var start = add.apply(void 0, _toConsumableArray(path.length.map(function (l, i) {\n    return cond(lessThan(i, index), l, 0);\n  })));\n  return add(start, multiply(t, length));\n};","map":{"version":3,"mappings":"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","names":["Animated","parseSVG","absSVG","normalizeSVG","get","string","cubicBezier","cubicBezierLength","cubicBezierSolve","Value","lessOrEq","greaterOrEq","and","cond","interpolate","multiply","lessThan","concat","add","MX","MY","CX1","CY1","CX2","CY2","CX","CY","parsePath","d","_normalizeSVG2","move","curves","parts","map","curve","index","prevCurve","p0","x","y","p1","p2","p3","length","segments","part","start","slice","reduce","acc","p","end","p0x","p3x","totalLength","segment","p0y","p1x","p1y","p2x","p2y","p3y","getPointAtLength","path","notFound","i","t","inputRange","outputRange","interpolatePath","value","config","paths","commands","_","interpolatePoint","point","mx","my","bInterpolatePath","path1","path2","getLengthAtX","l"],"sources":["SVG.ts"],"sourcesContent":["import Animated from \"react-native-reanimated\";\nimport parseSVG from \"parse-svg-path\";\nimport absSVG from \"abs-svg-path\";\nimport normalizeSVG from \"normalize-svg-path\";\n\nimport { get } from \"./Array\";\nimport { string } from \"./String\";\nimport { cubicBezier } from \"./Math\";\nimport cubicBezierLength from \"./bezier/CubicBezierLength\";\nimport cubicBezierSolve from \"./bezier/CubicBezierSolve\";\n\nconst {\n  Value,\n  lessOrEq,\n  greaterOrEq,\n  and,\n  cond,\n  interpolate,\n  multiply,\n  lessThan,\n  concat,\n  add,\n} = Animated;\n\n// const COMMAND = 0;\nconst MX = 1;\nconst MY = 2;\nconst CX1 = 1;\nconst CY1 = 2;\nconst CX2 = 3;\nconst CY2 = 4;\nconst CX = 5;\nconst CY = 6;\n\ntype SVGMoveCommand = [\"M\", number, number];\ntype SVGCurveCommand = [\"C\", number, number, number, number, number, number];\ntype SVGNormalizedCommands = [SVGMoveCommand, ...SVGCurveCommand[]];\ntype BezierPoint =\n  | \"p0x\"\n  | \"p0y\"\n  | \"p1x\"\n  | \"p1y\"\n  | \"p2x\"\n  | \"p2y\"\n  | \"p3x\"\n  | \"p3y\";\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\ninterface BezierCubicCurve {\n  length: number;\n  p0: Point;\n  p1: Point;\n  p2: Point;\n  p3: Point;\n}\n\nexport interface PathInterpolationConfig {\n  inputRange: readonly Animated.Adaptable<number>[];\n  outputRange: readonly (ReanimatedPath | string)[];\n  extrapolate?: Animated.Extrapolate;\n  extrapolateLeft?: Animated.Extrapolate;\n  extrapolateRight?: Animated.Extrapolate;\n}\n\nexport interface ReanimatedPath {\n  totalLength: number;\n  segments: { start: number; end: number; p0x: number; p3x: number }[];\n  length: number[];\n  start: number[];\n  end: number[];\n  p0x: number[];\n  p0y: number[];\n  p1x: number[];\n  p1y: number[];\n  p2x: number[];\n  p2y: number[];\n  p3x: number[];\n  p3y: number[];\n}\n\nexport const parsePath = (d: string): ReanimatedPath => {\n  const [move, ...curves]: SVGNormalizedCommands = normalizeSVG(\n    absSVG(parseSVG(d))\n  );\n  const parts: BezierCubicCurve[] = curves.map((curve, index) => {\n    const prevCurve = curves[index - 1];\n    const p0 =\n      index === 0\n        ? { x: move[MX], y: move[MY] }\n        : { x: prevCurve[CX], y: prevCurve[CY] };\n    const p1 = { x: curve[CX1], y: curve[CY1] };\n    const p2 = { x: curve[CX2], y: curve[CY2] };\n    const p3 = { x: curve[CX], y: curve[CY] };\n    const length = cubicBezierLength(p0, p1, p2, p3);\n    return {\n      p0,\n      p1,\n      p2,\n      p3,\n      length,\n    };\n  });\n  const segments = parts.map((part, index) => {\n    const start = parts.slice(0, index).reduce((acc, p) => acc + p.length, 0);\n    const end = start + part.length;\n    return {\n      start,\n      end,\n      p0x: part.p0.x,\n      p3x: part.p3.x,\n    };\n  });\n  return {\n    segments,\n    totalLength: parts.reduce((acc, part) => acc + part.length, 0),\n    length: parts.map((part) => part.length),\n    start: segments.map((segment) => segment.start),\n    end: segments.map((segment) => segment.end),\n    p0x: parts.map((part) => part.p0.x),\n    p0y: parts.map((part) => part.p0.y),\n    p1x: parts.map((part) => part.p1.x),\n    p1y: parts.map((part) => part.p1.y),\n    p2x: parts.map((part) => part.p2.x),\n    p2y: parts.map((part) => part.p2.y),\n    p3x: parts.map((part) => part.p3.x),\n    p3y: parts.map((part) => part.p3.y),\n  };\n};\n\nexport const getPointAtLength = (\n  path: ReanimatedPath,\n  length: Animated.Adaptable<number>\n): { x: Animated.Node<number>; y: Animated.Node<number> } => {\n  const notFound: Animated.Node<number> = new Value(-1);\n  const index = path.segments.reduce(\n    (acc, p, i) =>\n      cond(and(greaterOrEq(length, p.start), lessOrEq(length, p.end)), i, acc),\n    notFound\n  );\n  const start = get(path.start, index);\n  const end = get(path.end, index);\n\n  const p0x = get(path.p0x, index);\n  const p1x = get(path.p1x, index);\n  const p2x = get(path.p2x, index);\n  const p3x = get(path.p3x, index);\n\n  const p0y = get(path.p0y, index);\n  const p1y = get(path.p1y, index);\n  const p2y = get(path.p2y, index);\n  const p3y = get(path.p3y, index);\n  const t = interpolate(length, {\n    inputRange: [start, end],\n    outputRange: [0, 1],\n  });\n  return {\n    x: cubicBezier(t, p0x, p1x, p2x, p3x),\n    y: cubicBezier(t, p0y, p1y, p2y, p3y),\n  };\n};\n\nexport const interpolatePath = (\n  value: Animated.Adaptable<number>,\n  { inputRange, outputRange, ...config }: PathInterpolationConfig\n): Animated.Node<string> => {\n  const paths = outputRange.map((path) =>\n    typeof path === \"string\" ? parsePath(path) : path\n  );\n  const [path] = paths;\n  const commands = path.segments.map((_, index) => {\n    const interpolatePoint = (point: BezierPoint) =>\n      interpolate(value, {\n        inputRange,\n        outputRange: paths.map((p) => p[point][index]),\n        ...config,\n      });\n\n    const mx = interpolatePoint(\"p0x\");\n    const my = interpolatePoint(\"p0y\");\n\n    const p1x = interpolatePoint(\"p1x\");\n    const p1y = interpolatePoint(\"p1y\");\n\n    const p2x = interpolatePoint(\"p2x\");\n    const p2y = interpolatePoint(\"p2y\");\n\n    const p3x = interpolatePoint(\"p3x\");\n    const p3y = interpolatePoint(\"p3y\");\n\n    return string`${\n      index === 0 ? string`M${mx},${my} ` : \"\"\n    }C${p1x},${p1y} ${p2x},${p2y} ${p3x},${p3y}`;\n  });\n  return concat(...commands);\n};\n\nexport const bInterpolatePath = (\n  value: Animated.Value<number>,\n  path1: ReanimatedPath | string,\n  path2: ReanimatedPath | string\n): Animated.Node<string> =>\n  interpolatePath(value, {\n    inputRange: [0, 1],\n    outputRange: [path1, path2],\n  });\n\n// https://pomax.github.io/bezierinfo/#yforx\nexport const getLengthAtX = (\n  path: ReanimatedPath,\n  x: Animated.Adaptable<number>\n): Animated.Node<number> => {\n  const notFound: Animated.Node<number> = new Value(-1);\n  const index = path.segments.reduce(\n    (acc, p, i) => cond(and(greaterOrEq(x, p.p0x), lessOrEq(x, p.p3x)), i, acc),\n    notFound\n  );\n  const p0 = get(path.p0x, index);\n  const p1 = get(path.p1x, index);\n  const p2 = get(path.p2x, index);\n  const p3 = get(path.p3x, index);\n  const t = cubicBezierSolve(p0, p1, p2, p3);\n  const length = get(path.length, index);\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  const start = add(\n    ...(path.length.map((l, i) => cond(lessThan(i, index), l, 0)) as [\n      any,\n      any,\n      ...any[]\n    ])\n  );\n  /* eslint-enable @typescript-eslint/no-explicit-any */\n  return add(start, multiply(t, length));\n};\n"]},"metadata":{},"sourceType":"module"}
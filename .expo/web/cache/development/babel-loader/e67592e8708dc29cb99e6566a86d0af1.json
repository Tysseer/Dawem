{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { PermissionStatus, createPermissionHook, EventEmitter, Platform } from 'expo-modules-core';\nimport { _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS } from \"../AV\";\nimport ExponentAV from \"../ExponentAV\";\nimport { isAudioEnabled, throwIfAudioIsDisabled } from \"./AudioAvailability\";\nimport { RECORDING_OPTIONS_PRESET_LOW_QUALITY } from \"./RecordingConstants\";\nimport { Sound } from \"./Sound\";\nvar _recorderExists = false;\nvar eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\nexport function getPermissionsAsync() {\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", ExponentAV.getPermissionsAsync());\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          return _context2.abrupt(\"return\", ExponentAV.requestPermissionsAsync());\n        case 1:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport var usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync\n});\nexport var Recording = function () {\n  function Recording() {\n    var _this = this;\n    _classCallCheck(this, Recording);\n    this._subscription = null;\n    this._canRecord = false;\n    this._isDoneRecording = false;\n    this._finalDurationMillis = 0;\n    this._uri = null;\n    this._onRecordingStatusUpdate = null;\n    this._progressUpdateTimeoutVariable = null;\n    this._progressUpdateIntervalMillis = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n    this._options = null;\n    this._cleanupForUnloadedRecorder = function _callee(finalStatus) {\n      var _finalStatus$duration;\n      return _regeneratorRuntime.async(function _callee$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _this._canRecord = false;\n              _this._isDoneRecording = true;\n              _this._finalDurationMillis = (_finalStatus$duration = finalStatus == null ? void 0 : finalStatus.durationMillis) != null ? _finalStatus$duration : 0;\n              _recorderExists = false;\n              if (_this._subscription) {\n                _this._subscription.remove();\n                _this._subscription = null;\n              }\n              _this._disablePolling();\n              _context3.next = 8;\n              return _regeneratorRuntime.awrap(_this.getStatusAsync());\n            case 8:\n              return _context3.abrupt(\"return\", _context3.sent);\n            case 9:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n    this._pollingLoop = function _callee2() {\n      return _regeneratorRuntime.async(function _callee2$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (!(isAudioEnabled() && _this._canRecord && _this._onRecordingStatusUpdate != null)) {\n                _context4.next = 10;\n                break;\n              }\n              _this._progressUpdateTimeoutVariable = setTimeout(_this._pollingLoop, _this._progressUpdateIntervalMillis);\n              _context4.prev = 2;\n              _context4.next = 5;\n              return _regeneratorRuntime.awrap(_this.getStatusAsync());\n            case 5:\n              _context4.next = 10;\n              break;\n            case 7:\n              _context4.prev = 7;\n              _context4.t0 = _context4[\"catch\"](2);\n              _this._disablePolling();\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, null, null, [[2, 7]], Promise);\n    };\n    this.getStatusAsync = function _callee3() {\n      var status;\n      return _regeneratorRuntime.async(function _callee3$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (!_this._canRecord) {\n                _context5.next = 2;\n                break;\n              }\n              return _context5.abrupt(\"return\", _this._performOperationAndHandleStatusAsync(function () {\n                return ExponentAV.getAudioRecordingStatus();\n              }));\n            case 2:\n              status = {\n                canRecord: false,\n                isRecording: false,\n                isDoneRecording: _this._isDoneRecording,\n                durationMillis: _this._finalDurationMillis\n              };\n              _this._callOnRecordingStatusUpdateForNewStatus(status);\n              return _context5.abrupt(\"return\", status);\n            case 5:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n  }\n  _createClass(Recording, [{\n    key: \"_disablePolling\",\n    value: function _disablePolling() {\n      if (this._progressUpdateTimeoutVariable != null) {\n        clearTimeout(this._progressUpdateTimeoutVariable);\n        this._progressUpdateTimeoutVariable = null;\n      }\n    }\n  }, {\n    key: \"_enablePollingIfNecessaryAndPossible\",\n    value: function _enablePollingIfNecessaryAndPossible() {\n      if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n        this._disablePolling();\n        this._pollingLoop();\n      }\n    }\n  }, {\n    key: \"_callOnRecordingStatusUpdateForNewStatus\",\n    value: function _callOnRecordingStatusUpdateForNewStatus(status) {\n      if (this._onRecordingStatusUpdate != null) {\n        this._onRecordingStatusUpdate(status);\n      }\n    }\n  }, {\n    key: \"_performOperationAndHandleStatusAsync\",\n    value: function _performOperationAndHandleStatusAsync(operation) {\n      var status;\n      return _regeneratorRuntime.async(function _performOperationAndHandleStatusAsync$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              throwIfAudioIsDisabled();\n              if (!this._canRecord) {\n                _context6.next = 9;\n                break;\n              }\n              _context6.next = 4;\n              return _regeneratorRuntime.awrap(operation());\n            case 4:\n              status = _context6.sent;\n              this._callOnRecordingStatusUpdateForNewStatus(status);\n              return _context6.abrupt(\"return\", status);\n            case 9:\n              throw new Error('Cannot complete operation because this recorder is not ready to record.');\n            case 10:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"setOnRecordingStatusUpdate\",\n    value: function setOnRecordingStatusUpdate(onRecordingStatusUpdate) {\n      this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n      if (onRecordingStatusUpdate == null) {\n        this._disablePolling();\n      } else {\n        this._enablePollingIfNecessaryAndPossible();\n      }\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"setProgressUpdateInterval\",\n    value: function setProgressUpdateInterval(progressUpdateIntervalMillis) {\n      this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n      this.getStatusAsync();\n    }\n  }, {\n    key: \"prepareToRecordAsync\",\n    value: function prepareToRecordAsync() {\n      var options,\n        extensionRegex,\n        _await$ExponentAV$pre,\n        uri,\n        status,\n        currentStatus,\n        _args7 = arguments;\n      return _regeneratorRuntime.async(function prepareToRecordAsync$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              options = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : RECORDING_OPTIONS_PRESET_LOW_QUALITY;\n              throwIfAudioIsDisabled();\n              if (!_recorderExists) {\n                _context7.next = 4;\n                break;\n              }\n              throw new Error('Only one Recording object can be prepared at a given time.');\n            case 4:\n              if (!this._isDoneRecording) {\n                _context7.next = 6;\n                break;\n              }\n              throw new Error('This Recording object is done recording; you must make a new one.');\n            case 6:\n              if (!(!options || !options.android || !options.ios)) {\n                _context7.next = 8;\n                break;\n              }\n              throw new Error('You must provide recording options for android and ios in order to prepare to record.');\n            case 8:\n              extensionRegex = /^\\.\\w+$/;\n              if (!(!options.android.extension || !options.ios.extension || !extensionRegex.test(options.android.extension) || !extensionRegex.test(options.ios.extension))) {\n                _context7.next = 11;\n                break;\n              }\n              throw new Error(\"Your file extensions must match \" + extensionRegex.toString() + \".\");\n            case 11:\n              if (this._canRecord) {\n                _context7.next = 28;\n                break;\n              }\n              if (eventEmitter) {\n                this._subscription = eventEmitter.addListener('Expo.Recording.recorderUnloaded', this._cleanupForUnloadedRecorder);\n              }\n              _context7.next = 15;\n              return _regeneratorRuntime.awrap(ExponentAV.prepareAudioRecorder(options));\n            case 15:\n              _await$ExponentAV$pre = _context7.sent;\n              uri = _await$ExponentAV$pre.uri;\n              status = _await$ExponentAV$pre.status;\n              _recorderExists = true;\n              this._uri = uri;\n              this._options = options;\n              this._canRecord = true;\n              currentStatus = _objectSpread(_objectSpread({}, status), {}, {\n                canRecord: true\n              });\n              this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n              this._enablePollingIfNecessaryAndPossible();\n              return _context7.abrupt(\"return\", currentStatus);\n            case 28:\n              throw new Error('This Recording object is already prepared to record.');\n            case 29:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"startAsync\",\n    value: function startAsync() {\n      return _regeneratorRuntime.async(function startAsync$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              return _context8.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n                return ExponentAV.startAudioRecording();\n              }));\n            case 1:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"pauseAsync\",\n    value: function pauseAsync() {\n      return _regeneratorRuntime.async(function pauseAsync$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              return _context9.abrupt(\"return\", this._performOperationAndHandleStatusAsync(function () {\n                return ExponentAV.pauseAudioRecording();\n              }));\n            case 1:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"stopAndUnloadAsync\",\n    value: function stopAndUnloadAsync() {\n      var _stopResult;\n      var stopResult, stopError, status;\n      return _regeneratorRuntime.async(function stopAndUnloadAsync$(_context10) {\n        while (1) {\n          switch (_context10.prev = _context10.next) {\n            case 0:\n              if (this._canRecord) {\n                _context10.next = 6;\n                break;\n              }\n              if (!this._isDoneRecording) {\n                _context10.next = 5;\n                break;\n              }\n              throw new Error('Cannot unload a Recording that has already been unloaded.');\n            case 5:\n              throw new Error('Cannot unload a Recording that has not been prepared.');\n            case 6:\n              _context10.prev = 6;\n              _context10.next = 9;\n              return _regeneratorRuntime.awrap(ExponentAV.stopAudioRecording());\n            case 9:\n              stopResult = _context10.sent;\n              _context10.next = 15;\n              break;\n            case 12:\n              _context10.prev = 12;\n              _context10.t0 = _context10[\"catch\"](6);\n              stopError = _context10.t0;\n            case 15:\n              if (Platform.OS === 'web' && ((_stopResult = stopResult) == null ? void 0 : _stopResult.uri) !== undefined) {\n                this._uri = stopResult.uri;\n              }\n              _context10.next = 18;\n              return _regeneratorRuntime.awrap(ExponentAV.unloadAudioRecorder());\n            case 18:\n              _context10.next = 20;\n              return _regeneratorRuntime.awrap(this._cleanupForUnloadedRecorder(stopResult));\n            case 20:\n              status = _context10.sent;\n              return _context10.abrupt(\"return\", stopError ? Promise.reject(stopError) : status);\n            case 22:\n            case \"end\":\n              return _context10.stop();\n          }\n        }\n      }, null, this, [[6, 12]], Promise);\n    }\n  }, {\n    key: \"getURI\",\n    value: function getURI() {\n      return this._uri;\n    }\n  }, {\n    key: \"createNewLoadedSound\",\n    value: function createNewLoadedSound() {\n      var initialStatus,\n        onPlaybackStatusUpdate,\n        _args11 = arguments;\n      return _regeneratorRuntime.async(function createNewLoadedSound$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              initialStatus = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {};\n              onPlaybackStatusUpdate = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : null;\n              console.warn(\"createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name\");\n              return _context11.abrupt(\"return\", this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate));\n            case 4:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"createNewLoadedSoundAsync\",\n    value: function createNewLoadedSoundAsync() {\n      var initialStatus,\n        onPlaybackStatusUpdate,\n        _args12 = arguments;\n      return _regeneratorRuntime.async(function createNewLoadedSoundAsync$(_context12) {\n        while (1) {\n          switch (_context12.prev = _context12.next) {\n            case 0:\n              initialStatus = _args12.length > 0 && _args12[0] !== undefined ? _args12[0] : {};\n              onPlaybackStatusUpdate = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : null;\n              if (!(this._uri == null || !this._isDoneRecording)) {\n                _context12.next = 4;\n                break;\n              }\n              throw new Error('Cannot create sound when the Recording has not finished!');\n            case 4:\n              return _context12.abrupt(\"return\", Sound.createAsync({\n                uri: this._uri\n              }, initialStatus, onPlaybackStatusUpdate, false));\n            case 5:\n            case \"end\":\n              return _context12.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }]);\n  return Recording;\n}();\nRecording.createAsync = function _callee4() {\n  var options,\n    onRecordingStatusUpdate,\n    progressUpdateIntervalMillis,\n    recording,\n    status,\n    _args13 = arguments;\n  return _regeneratorRuntime.async(function _callee4$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          options = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : RECORDING_OPTIONS_PRESET_LOW_QUALITY;\n          onRecordingStatusUpdate = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : null;\n          progressUpdateIntervalMillis = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : null;\n          recording = new Recording();\n          if (progressUpdateIntervalMillis) {\n            recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n          }\n          recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n          _context13.next = 8;\n          return _regeneratorRuntime.awrap(recording.prepareToRecordAsync(_objectSpread(_objectSpread({}, options), {}, {\n            keepAudioActiveHint: true\n          })));\n        case 8:\n          _context13.prev = 8;\n          _context13.next = 11;\n          return _regeneratorRuntime.awrap(recording.startAsync());\n        case 11:\n          status = _context13.sent;\n          return _context13.abrupt(\"return\", {\n            recording: recording,\n            status: status\n          });\n        case 15:\n          _context13.prev = 15;\n          _context13.t0 = _context13[\"catch\"](8);\n          recording.stopAndUnloadAsync();\n          throw _context13.t0;\n        case 19:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, null, null, [[8, 15]], Promise);\n};\nexport * from \"./RecordingConstants\";\nexport { PermissionStatus };","map":{"version":3,"mappings":"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","names":["PermissionStatus","createPermissionHook","EventEmitter","Platform","_DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS","ExponentAV","isAudioEnabled","throwIfAudioIsDisabled","RECORDING_OPTIONS_PRESET_LOW_QUALITY","Sound","_recorderExists","eventEmitter","OS","getPermissionsAsync","requestPermissionsAsync","usePermissions","getMethod","requestMethod","Recording","_subscription","_canRecord","_isDoneRecording","_finalDurationMillis","_uri","_onRecordingStatusUpdate","_progressUpdateTimeoutVariable","_progressUpdateIntervalMillis","_options","_cleanupForUnloadedRecorder","finalStatus","durationMillis","remove","_disablePolling","getStatusAsync","_pollingLoop","setTimeout","_performOperationAndHandleStatusAsync","getAudioRecordingStatus","status","canRecord","isRecording","isDoneRecording","_callOnRecordingStatusUpdateForNewStatus","clearTimeout","operation","Error","onRecordingStatusUpdate","_enablePollingIfNecessaryAndPossible","progressUpdateIntervalMillis","options","android","ios","extensionRegex","extension","test","toString","addListener","prepareAudioRecorder","uri","currentStatus","startAudioRecording","pauseAudioRecording","stopAudioRecording","stopResult","stopError","undefined","unloadAudioRecorder","Promise","reject","initialStatus","onPlaybackStatusUpdate","console","warn","createNewLoadedSoundAsync","createAsync","recording","setOnRecordingStatusUpdate","prepareToRecordAsync","keepAudioActiveHint","startAsync","stopAndUnloadAsync"],"sourceRoot":"","sources":["../../src/Audio/Recording.ts"],"sourcesContent":["import {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  Platform,\n} from 'expo-modules-core';\n\nimport {\n  _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS,\n  AVPlaybackStatus,\n  AVPlaybackStatusToSet,\n} from '../AV';\nimport ExponentAV from '../ExponentAV';\nimport { isAudioEnabled, throwIfAudioIsDisabled } from './AudioAvailability';\nimport { RecordingOptions, RecordingStatus } from './Recording.types';\nimport { RECORDING_OPTIONS_PRESET_LOW_QUALITY } from './RecordingConstants';\nimport { Sound } from './Sound';\n\nlet _recorderExists: boolean = false;\nconst eventEmitter = Platform.OS === 'android' ? new EventEmitter(ExponentAV) : null;\n\nexport async function getPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.getPermissionsAsync();\n}\n\nexport async function requestPermissionsAsync(): Promise<PermissionResponse> {\n  return ExponentAV.requestPermissionsAsync();\n}\n\n/**\n * Check or request permissions to record audio.\n * This uses both `requestPermissionAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = Audio.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook({\n  getMethod: getPermissionsAsync,\n  requestMethod: requestPermissionsAsync,\n});\n\nexport class Recording {\n  _subscription: Subscription | null = null;\n  _canRecord: boolean = false;\n  _isDoneRecording: boolean = false;\n  _finalDurationMillis: number = 0;\n  _uri: string | null = null;\n  _onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null;\n  _progressUpdateTimeoutVariable: number | null = null;\n  _progressUpdateIntervalMillis: number = _DEFAULT_PROGRESS_UPDATE_INTERVAL_MILLIS;\n  _options: RecordingOptions | null = null;\n\n  // Internal methods\n\n  _cleanupForUnloadedRecorder = async (finalStatus?: RecordingStatus) => {\n    this._canRecord = false;\n    this._isDoneRecording = true;\n    this._finalDurationMillis = finalStatus?.durationMillis ?? 0;\n    _recorderExists = false;\n    if (this._subscription) {\n      this._subscription.remove();\n      this._subscription = null;\n    }\n    this._disablePolling();\n    return await this.getStatusAsync(); // Automatically calls onRecordingStatusUpdate for the final state.\n  };\n\n  _pollingLoop = async () => {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._progressUpdateTimeoutVariable = setTimeout(\n        this._pollingLoop,\n        this._progressUpdateIntervalMillis\n      ) as any;\n      try {\n        await this.getStatusAsync();\n      } catch (error) {\n        this._disablePolling();\n      }\n    }\n  };\n\n  _disablePolling() {\n    if (this._progressUpdateTimeoutVariable != null) {\n      clearTimeout(this._progressUpdateTimeoutVariable);\n      this._progressUpdateTimeoutVariable = null;\n    }\n  }\n\n  _enablePollingIfNecessaryAndPossible() {\n    if (isAudioEnabled() && this._canRecord && this._onRecordingStatusUpdate != null) {\n      this._disablePolling();\n      this._pollingLoop();\n    }\n  }\n\n  _callOnRecordingStatusUpdateForNewStatus(status: RecordingStatus) {\n    if (this._onRecordingStatusUpdate != null) {\n      this._onRecordingStatusUpdate(status);\n    }\n  }\n\n  async _performOperationAndHandleStatusAsync(\n    operation: () => Promise<RecordingStatus>\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n    if (this._canRecord) {\n      const status = await operation();\n      this._callOnRecordingStatusUpdateForNewStatus(status);\n      return status;\n    } else {\n      throw new Error('Cannot complete operation because this recorder is not ready to record.');\n    }\n  }\n\n  // Note that all calls automatically call onRecordingStatusUpdate as a side effect.\n\n  static createAsync = async (\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY,\n    onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null = null,\n    progressUpdateIntervalMillis: number | null = null\n  ): Promise<{ recording: Recording; status: RecordingStatus }> => {\n    const recording: Recording = new Recording();\n    if (progressUpdateIntervalMillis) {\n      recording._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    }\n    recording.setOnRecordingStatusUpdate(onRecordingStatusUpdate);\n    await recording.prepareToRecordAsync({\n      ...options,\n      keepAudioActiveHint: true,\n    });\n    try {\n      const status = await recording.startAsync();\n      return { recording, status };\n    } catch (err) {\n      recording.stopAndUnloadAsync();\n      throw err;\n    }\n  };\n\n  // Get status API\n\n  getStatusAsync = async (): Promise<RecordingStatus> => {\n    // Automatically calls onRecordingStatusUpdate.\n    if (this._canRecord) {\n      return this._performOperationAndHandleStatusAsync(() => ExponentAV.getAudioRecordingStatus());\n    }\n    const status = {\n      canRecord: false,\n      isRecording: false,\n      isDoneRecording: this._isDoneRecording,\n      durationMillis: this._finalDurationMillis,\n    };\n    this._callOnRecordingStatusUpdateForNewStatus(status);\n    return status;\n  };\n\n  setOnRecordingStatusUpdate(onRecordingStatusUpdate: ((status: RecordingStatus) => void) | null) {\n    this._onRecordingStatusUpdate = onRecordingStatusUpdate;\n    if (onRecordingStatusUpdate == null) {\n      this._disablePolling();\n    } else {\n      this._enablePollingIfNecessaryAndPossible();\n    }\n    this.getStatusAsync();\n  }\n\n  setProgressUpdateInterval(progressUpdateIntervalMillis: number) {\n    this._progressUpdateIntervalMillis = progressUpdateIntervalMillis;\n    this.getStatusAsync();\n  }\n\n  // Record API\n\n  async prepareToRecordAsync(\n    options: RecordingOptions = RECORDING_OPTIONS_PRESET_LOW_QUALITY\n  ): Promise<RecordingStatus> {\n    throwIfAudioIsDisabled();\n\n    if (_recorderExists) {\n      throw new Error('Only one Recording object can be prepared at a given time.');\n    }\n\n    if (this._isDoneRecording) {\n      throw new Error('This Recording object is done recording; you must make a new one.');\n    }\n\n    if (!options || !options.android || !options.ios) {\n      throw new Error(\n        'You must provide recording options for android and ios in order to prepare to record.'\n      );\n    }\n\n    const extensionRegex = /^\\.\\w+$/;\n    if (\n      !options.android.extension ||\n      !options.ios.extension ||\n      !extensionRegex.test(options.android.extension) ||\n      !extensionRegex.test(options.ios.extension)\n    ) {\n      throw new Error(`Your file extensions must match ${extensionRegex.toString()}.`);\n    }\n\n    if (!this._canRecord) {\n      if (eventEmitter) {\n        this._subscription = eventEmitter.addListener(\n          'Expo.Recording.recorderUnloaded',\n          this._cleanupForUnloadedRecorder\n        );\n      }\n\n      const {\n        uri,\n        status,\n      }: {\n        uri: string | null;\n        // status is of type RecordingStatus, but without the canRecord field populated\n        status: Pick<RecordingStatus, Exclude<keyof RecordingStatus, 'canRecord'>>;\n      } = await ExponentAV.prepareAudioRecorder(options);\n      _recorderExists = true;\n      this._uri = uri;\n      this._options = options;\n      this._canRecord = true;\n\n      const currentStatus = { ...status, canRecord: true };\n      this._callOnRecordingStatusUpdateForNewStatus(currentStatus);\n      this._enablePollingIfNecessaryAndPossible();\n      return currentStatus;\n    } else {\n      throw new Error('This Recording object is already prepared to record.');\n    }\n  }\n\n  async startAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.startAudioRecording());\n  }\n\n  async pauseAsync(): Promise<RecordingStatus> {\n    return this._performOperationAndHandleStatusAsync(() => ExponentAV.pauseAudioRecording());\n  }\n\n  async stopAndUnloadAsync(): Promise<RecordingStatus> {\n    if (!this._canRecord) {\n      if (this._isDoneRecording) {\n        throw new Error('Cannot unload a Recording that has already been unloaded.');\n      } else {\n        throw new Error('Cannot unload a Recording that has not been prepared.');\n      }\n    }\n    // We perform a separate native API call so that the state of the Recording can be updated with\n    // the final duration of the recording. (We cast stopStatus as Object to appease Flow)\n    let stopResult: RecordingStatus | undefined;\n    let stopError: Error | undefined;\n    try {\n      stopResult = await ExponentAV.stopAudioRecording();\n    } catch (err) {\n      stopError = err;\n    }\n\n    // Web has to return the URI at the end of recording, so needs a little destructuring\n    if (Platform.OS === 'web' && stopResult?.uri !== undefined) {\n      this._uri = stopResult.uri;\n    }\n\n    // Clean-up and return status\n    await ExponentAV.unloadAudioRecorder();\n    const status = await this._cleanupForUnloadedRecorder(stopResult);\n    return stopError ? Promise.reject(stopError) : status;\n  }\n\n  // Read API\n\n  getURI(): string | null {\n    return this._uri;\n  }\n\n  /** @deprecated Use `createNewLoadedSoundAsync()` instead */\n  async createNewLoadedSound(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    console.warn(\n      `createNewLoadedSound is deprecated in favor of createNewLoadedSoundAsync, which has the same API aside from the method name`\n    );\n    return this.createNewLoadedSoundAsync(initialStatus, onPlaybackStatusUpdate);\n  }\n\n  async createNewLoadedSoundAsync(\n    initialStatus: AVPlaybackStatusToSet = {},\n    onPlaybackStatusUpdate: ((status: AVPlaybackStatus) => void) | null = null\n  ): Promise<{ sound: Sound; status: AVPlaybackStatus }> {\n    if (this._uri == null || !this._isDoneRecording) {\n      throw new Error('Cannot create sound when the Recording has not finished!');\n    }\n    return Sound.createAsync(\n      // $FlowFixMe: Flow can't distinguish between this literal and Asset\n      { uri: this._uri },\n      initialStatus,\n      onPlaybackStatusUpdate,\n      false\n    );\n  }\n}\n\nexport * from './RecordingConstants';\n\nexport {\n  PermissionResponse,\n  PermissionStatus,\n  PermissionHookOptions,\n  RecordingOptions,\n  RecordingStatus,\n};\n"]},"metadata":{},"sourceType":"module"}